---
title: 'Linux常用命令'
publishDate: '2020-08-18 12:00:00'
description: ''
tags:
  - operating-system
  - 实用技巧
  - 计算机系统
language: '中文'
heroImage: {"src":"./linux-logo.png","color":"#B4C6DA"}
---

\[toc\]

## 前言

整理 `Linux` 中的常用命令，方便查看使用。提供一个查询命令的网站[linux-command](https://wangchujiang.com/linux-command/ "linux-command")。也可以用 `man` 命令查看对应命令的说明。

> 本文主要介绍 `Linux` 的常用命令，对 `shell` 的介绍和特殊符号的含义请查看另一篇文章[Shell脚本语法和常用命令](https://www.clloz.com/programming/backend/server/2019/11/01/shell-script-syntax/ "Shell脚本语法和常用命令")

## 命令

## man 命令

`man` 命令 是 `Linux` 下的帮助指令 (`manual)`，通过 `man` 指令可以查看 `Linux` 中的指令帮助、配置文件帮助和编程帮助等信息。 `man(选项)(参数)` 参数可以是数字或者关键字，数字是指定从哪本man手册中搜索帮助，关键字是指定要搜索帮助的关键字。数字有如下几种：

1. 用户在 `shell` 环境可操作的命令或执行文件；
2. 系统内核可调用的函数与工具等
3. 一些常用的函数(`function`)与函数库(`library`)，大部分为C的函数库(libc)
4. 设备文件说明，通常在/dev下的文件
5. 配置文件或某些文件格式
6. 游戏(games)
7. 惯例与协议等，如Linux文件系统，网络协议，ASCII code等说明
8. 系统管理员可用的管理命令
9. 跟kernel有关的文件

```bash
# 选项
man -a #在所有的man帮助手册中搜索；
man -f # 等价于whatis指令，显示给定关键字的简短描述信息；
man -P # 指定内容时使用分页程序；
man -M # 指定man手册搜索的路径。
```

> 我们输入 `man ls`，它会在最左上角显示 `LS（1）`，在这里，`LS` 表示手册名称，而 `（1）` 表示该手册位于第一节章，同样，我们输 `man ifconfig` 它会在最左上角显示 `IFCONFIG（8）`。也可以这样输入命令：`man [章节号] 手册名称`。

## ls 命令

就是 `list` 的缩写，通过 `ls` 命令不仅可以查看 `linux` 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。

```bash
# 选项
ls -a # 列出目录所有文件，包含以.开始的隐藏文件
ls -A # 列出除.及..的其它文件
ls -r # 反序排列
ls -t # 以文件修改时间排序
ls -S #以文件大小排序
ls -h #以易读大小显示
ls -l #除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来
```

## cd 命令

切换当前目录。

```bash
# 选项
cd / # 进入根目录
cd ~ # 进入 "home" 目录
cd - # 进入上一次工作路径
cd !$ # 把上个命令的参数作为cd参数使用。
```

## pwd 命令

`pwd` 命令用于查看当前工作目录路径。

```bash
# 选项
pwd # 查看当前路径
pwd -P # 查看软连接的实际路径

```

## mkdir 命令

`mkdir` 命令用于创建文件夹。参数为目录，指定要创建的目录列表，多个目录之间用空格隔开。

```bash
# 选项
mkdir -Z # 设置安全上下文，当使用SELinux时有效；
mkdir -m || mkdir --mode # 建立目录的同时设置目录的权限；
mkdir -p || mkdir --parents # 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录；
mkdir --version # 显示版本信息。
```

## rm 命令

删除一个目录中的一个或多个文件或目录，如果没有使用 `-r` 选项，则 `rm` 不会删除目录。如果使用 `rm` 来删除文件，通常仍可以将该文件恢复原状。

```bash
# 选项
rm -d # 直接把欲删除的目录的硬连接数据删除成0，删除该目录；
rm -f # 强制删除文件或目录；
rm -i # 删除已有文件或目录之前先询问用户；
rm -r || rm -R # 递归处理，将指定目录下的所有文件与子目录一并处理；
rm --preserve-root #不对根目录进行递归操作；
rm -v # 显示指令的详细执行过程。
```

## rmdir 命令

`rmdir dirname`用来删除空目录。当目录不再被使用时，或者磁盘空间已到达使用限定值，就需要删除失去使用价值的目录。利用 `rmdir` 命令可以从一个目录中删除一个或多个空的子目录。该命令从一个目录中删除一个或多个子目录，其中 `dirname` 表示目录名。如果 `dirname` 中没有指定路径，则删除当前目录下由 `dirname` 指定的目录；如 `dirname` 中包含路径，则删除指定位置的目录。删除目录时，必须具有对其父目录的写权限。

> 子目录被删除之前应该是空目录。就是说，该目录中的所有文件必须用 `rm` 命令全部删除，另外，当前工作目录必须在被删除目录之上，不能是被删除目录本身，也不能是被删除目录的子目录。

```bash
# 选项
rmdir -p || rmdir --parents # 删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；
rmdir --ignore-fail-on-non-empty # 此选项使rmdir命令忽略由于删除非空目录时导致的错误信息；
rmdir -v || rmdir -verboes # 显示命令的详细执行过程；
rmdir --help # 显示命令的帮助信息；
rmdir --version # 显示命令的版本信息。
```

## mv 命令

`mv source target`用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。`source` 表示源文件或目录(源文件可以是多个文件，用空格分开，也可以使用通配符 `mv * ../`)，`target` 表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。

`mv` 命令可以用来将源文件移至一个目标文件中，或将一组文件移至一个目标目录中。源文件被移至目标文件有两种不同的结果：

1. 如果目标文件是到某一目录文件的路径，源文件会被移到此目录下，且文件名不变。
2. 如果目标文件不是目录文件，则源文件名(只能有一个)会变为此目标文件名，并覆盖己存在的同名文件。如果源文件和目标文件在同一个目录下，mv的作用就是改文件名。当目标文件是目录文件时，源文件或目录参数可以有多个，则所有的源文件都会被移至目标文件中。所有移到该目录下的文件都将保留以前的文件名。

> 注意事项：`mv` 与 `cp` 的结果不同，`mv` 好像文件“搬家”，文件个数并未增加。而 `cp` 对文件进行复制，文件个数增加了。

```bash
# 选项
mv --backup=<备份模式> # 若需覆盖文件，则覆盖前先行备份；
mv -b # 当文件存在时，覆盖前，为其创建一个备份；
mv -f # 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录；
mv -i # 交互式操作，覆盖前先行询问用户，如果源文件与目标文件或目标目录中的文件同名，则询问用户是否覆盖目标文件。用户输入”y”，表示将覆盖目标文件；输入”n”，表示取消对源文件的移动。这样可以避免误将文件覆盖。
mv --strip-trailing-slashes # 删除源文件中的斜杠“/”；
mv -S<后缀> # 为备份文件指定后缀，而不使用默认的后缀；
mv --target-directory=<目录> # 指定源文件要移动到目标目录；
mv -u # 当源文件比目标文件新或者目标文件不存在时，才执行移动操作。
```

## cp 命令

`cp source target` 用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。`cp` 命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。

```bash
# 选项
cp -a #此参数的效果和同时指定"-dpR"参数相同；
cp -d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；
cp -f # 强行复制文件或目录，不论目标文件或目录是否已存在；
cp -i # 覆盖既有文件之前先询问用户；
cp -l # 对源文件建立硬连接，而非复制文件；
cp -p # 保留源文件或目录的属性；
cp -R || cp r # 递归处理，将指定目录下的所有文件与子目录一并处理；
cp -s # 对源文件建立符号连接，而非复制文件；
cp -u # 使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；
cp -S # 在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；
cp -b # 覆盖已存在的文件目标前将目标文件备份；
cp -v # 详细显示命令执行的操作。
```

## cat 命令

`cat` 连接多个文件并打印到标准输出。

- 显示文件内容，如果没有文件或文件为-则读取标准输入。
- 将多个文件的内容进行连接并打印到标准输出。
- 显示文件内容中的不可见字符(控制字符、换行符、制表符等)。

```bash
# 选项
cat -A # --show-all 等价于"-vET"组合选项。
cat -b, # --number-nonblank 只对非空行编号，从1开始编号，覆盖"-n"选项。
cat -e  # 等价于"-vE"组合选项。
cat -E # --show-ends 在每行的结尾显示'$'字符。
cat -n # --number 对所有行编号，从1开始编号。
cat -s # --squeeze-blank 压缩连续的空行到一行。
cat -t # 等价于"-vT"组合选项。
cat -T # --show-tabs 使用"^I"表示TAB（制表符）。
cat -u  #  POSIX兼容性选项，无意义。
cat -v # --show-nonprinting   使用"^"和"M-"符号显示控制字符，除了LFD（line feed，即换行符'\n'）和TAB（制表符）。
cat --help                   显示帮助信息并退出。
cat --version                显示版本信息并退出。
```

## more 命令

是一个基于 `vi` 编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持 `vi` 中的关键字定位操作。`more` 名单中内置了若干快捷键，常用的有 `H`（获得帮助信息），`Enter`（向下翻滚一行），空格（向下滚动一屏），`Q`（退出命令）。语法 `more(选项)(参数)`。

该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：`--More--（XX%`）可以用下列不同的方法对提示做出回答：

- 按 `Space` 键：显示文本的下一屏内容。
- 按 `Enter` 键：只显示文本的下一行内容。
- 按斜线符`|`：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。
- 按 `H` 键：显示帮助屏，该屏上有相关的帮助信息。
- 按 `B` 键：显示上一屏内容。
- `Ctrl+F`: ：向下滚动一屏
- `Ctrl+B`：返回上一屏
- `=`：输出当前行的行号
- `:f`：输出文件名和当前行的行号
- `V`：调用vi编辑器
- `!命令`：调用 `Shell`，并执行命令
- `q`：退出 `more`

```bash
# 选项
more -<数字> # 指定每屏显示的行数；
more -d # 显示“[press space to continue,'q' to quit.]”和“[Press 'h' for instructions]”；
more -c # 不进行滚屏操作。每次刷新这个屏幕；
more -s # 将多个空行压缩成一行显示；
more -u # 禁止下划线；
more <数字> # 从指定数字的行开始显示。
```

## less 命令

`less` 命令 的作用与 `more` 十分相似，都可以用来浏览文字档案的内容，不同的是 `less` 命令允许用户向前或向后浏览文件，而 `more` 命令只能向前浏览，而且 less 在查看之前不会加载整个文件。用 `less` 命令显示文件时，用 `PageUp` 键向上翻页，用 `PageDown` 键向下翻页。要退出 `less` 程序，应按 `Q` 键。操作和选项如下。

- `/` 字符串：向下搜索“字符串”的功能
- `?` 字符串：向上搜索“字符串”的功能
- `n`：重复前一个搜索（与 / 或 ? 有关）
- `N`：反向重复前一个搜索（与 / 或 ? 有关）
- `-x` <数字> 将“tab”键显示为规定的数字空格
- `b` 向后翻一页
- `d` 向后翻半页
- `h` 显示帮助界面
- `Q` 退出less 命令
- `u` 向前滚动半页
- `y` 向前滚动一行
- 空格键 滚动一行
- 回车键 滚动一页
- `[pagedown]`： 向下翻动一页
- `[pageup]`： 向上翻动一页

语法 `less [选项] [参数]`

```bash
# 选项
less -e # 文件内容显示完毕后，自动退出；
less -f # 强制显示文件；
less -g # 不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；
less -l # 搜索时忽略大小写的差异；
less -N # 每一行行首显示行号；
less -s # 将连续多个空行压缩成一行显示；
less -S # 在单行显示较长的内容，而不换行显示；
less -x<数字> # 将TAB字符显示为指定个数的空格字符。
```

## head 命令

`head` 用来显示档案的开头至标准输出中，默认 `head` 命令打印其相应文件的开头 `10` 行。处理多个文件时会在各个文件之前附加含有文件名的行。当没有文件或文件为 `-` 时，读取标准输入。

语法 `head [选项] [参数]`

```bash
# 选项
head -n<行数> # 显示的行数（行数为负数表示从最后向前数）
```

## tail 命令

用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。

语法 `tail [选项] [参数]`

```bash
# 选项
tail -f # 循环读取（常用于查看递增的日志文件）
tail -n<行数> # 显示行数（从后向前）
tail -c<N> #——bytes=<N>：输出文件尾部的N（N为整数）个字节内容；
```

## env 命令

`env` 命令用于显示系统中已存在的环境变量，以及在定义的环境中执行指令。该命令只使用 `-` 作为参数选项时，隐藏了选项 `-i` 的功能。若没有设置任何选项和参数时，则直接显示当前的环境变量。

如果使用env命令在新环境中执行指令时，会因为没有定义环境变量"PATH"而提示错误信息 `such file or directory`。此时，用户可以重新定义一个新的"PATH"或者使用绝对路径。

语法 `env [选项] [参数]`

```bash
# 选项
env -i # 开始一个新的空的环境；
env -u<变量名> # 从当前环境中删除指定的变量。
```

参数可以是定义在新的环境中变量，定义多个变量定义用空格隔开。格式为`变量名=值`；也可以指定要执行的指令和参数。

## echo 命令

`echo` 命令用于在 `shell` 中打印 `shell` 变量的值，或者直接输出指定的字符串。`linux` 的 `echo` 命令，在 `shell` 编程中极为常用, 在终端下打印变量 `value` 的时候也是常常用到的，因此有必要了解下 `echo` 的用法 `echo` 命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。

语法 `echo [选项] [参数]`

```bash
# 选项
echo -e：激活转义字符。
```

使用 `-e` 选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：

- `\a` 发出警告声；
- `\b` 删除前一个字符；
- `\c` 不产生进一步输出 (\\c 后面的字符不会输出)；
- `\f` 换行但光标仍旧停留在原来的位置；
- `\n` 换行且光标移至行首；
- `\r` 光标移至行首，但不换行；
- `\t` 插入 `tab`；
- `\v` 与 `\f` 相同；
- `\\` 插入 `\` 字符；
- `\nnn` 插入 `nnn`（八进制）所代表的 `ASCII` 字符；

`echo` 命令还可以设置输出的样式，格式如下：

`echo -e "\033[字背景颜色；文字颜色m 字符串\033[0m"` `echo -e "\033[1;36;41m Something here \033[0m"`

- `\033` 代表键盘的 `Ctl` 键或 `Esc` 键（即 `ASCII` 码中的第 `27` 位 `ESCAPE`，八进制表示为 `33`）
- `1` 代表字体行为(高亮，闪烁，下划线等)；
- `36` 代表字体的颜色，
- `41` 的位置代表背景色

注意：字背景颜色和文字颜色之间是英文的分号 `;`，并且文字颜色后面有个 `m` ，字符串前后可以没有空格，如果有的话，输出也是同样有空格。在 `Bash` 中，`Esc` 字符可以用以下的语法来表示：`\e`，`\033`，`\x1B`。

* * *

字体颜色范围是 `30 - 37`, `0` 表示重置。

```bash
echo -e "\033[30m 黑色字 \033[0m"
echo -e "\033[31m 红色字 \033[0m"
echo -e "\033[32m 绿色字 \033[0m"
echo -e "\033[33m 黄色字 \033[0m"
echo -e "\033[34m 蓝色字 \033[0m"
echo -e "\033[35m 紫色字 \033[0m"
echo -e "\033[36m 天蓝字 \033[0m"
echo -e "\033[37m 白色字 \033[0m"
```

背景颜色范围是 `40 - 47`

```bash
echo -e "\033[40;37m 黑底白字 \033[0m" 
echo -e "\033[41;37m 红底白字 \033[0m" 
echo -e "\033[42;37m 绿底白字 \033[0m" 
echo -e "\033[43;37m 黄底白字 \033[0m" 
echo -e "\033[44;37m 蓝底白字 \033[0m" 
echo -e "\033[45;37m 紫底白字 \033[0m" 
echo -e "\033[46;37m 天蓝底白字 \033[0m" 
echo -e "\033[47;30m 白底黑字 \033[0m"
```

控制选项

```bash
033[0m # 关闭所有属性 
\033[1m # 设置高亮度 
\033[4m # 下划线 
\033[5m # 闪烁 
\033[7m # 反显 
\033[8m # 消隐 
\033[30m — \33[37m # 设置前景色 
\033[40m — \33[47m # 设置背景色 
\033[60A  # 光标上移60行 
\033[60B  # 光标下移60行 
\033[60C  # 光标右移60行 
\033[60G  # 光标右移60行
\033[60D  # 光标左移60行 
\033[y;xH # 设置光标位置 
\033[2J   # 清屏 
\033[K    # 清除从光标到行尾的内容 
\033[s    # 保存光标位置 
\033[u    # 恢复光标位置 
\033[?25l # 隐藏光标 
\033[?25h # 显示光标
```

结束非常规字符序列的 `m` 要紧跟前面的数字，不能有空格命令也可以写成`echo -e "^[[44;37;5m ME \033[0m COOL"`，其中的 `^[` 需要先按 `⌃ + V` 键 ,然后再按 `ESC` 键生成。

* * *

在 `RedHat` 系统的 `/etc/sysconfig/init` 文件中有事先设置好的输出方式。

```bash
# color => new RH6.0 bootup
# verbose => old-style bootup
# anything else => new style bootup without ANSI colors or positioning
BOOTUP=color
# column to start "[  OK  ]" label in
RES_COL=60
# terminal sequence to move to that column. You could change this
# to something like "tput hpa ${RES_COL}" if your terminal supports it
MOVE_TO_COL="echo -en \\033[${RES_COL}G"
# terminal sequence to set color to a 'success' color (currently: green)
SETCOLOR_SUCCESS="echo -en \\033[0;32m"
# terminal sequence to set color to a 'failure' color (currently: red)
SETCOLOR_FAILURE="echo -en \\033[0;31m"
# terminal sequence to set color to a 'warning' color (currently: yellow)
SETCOLOR_WARNING="echo -en \\033[0;33m"
# terminal sequence to reset to the default color.
SETCOLOR_NORMAL="echo -en \\033[0;39m"
```

```bash
# 实例
echo -e "\e[1;31mThis is red text\e[0m" #红色字体 

echo -e "\e[1;42mGreed Background\e[0m" # 绿色背景

echo -e "\033[37;31;5mMySQL Server Stop...\033[39;49;0m" #文字闪烁
```

> 文字和背景也可以设置更多颜色，参考网站[Bash tips: Colors and formatting (ANSI/VT100 Control sequences)](https://misc.flogisoft.com/bash/tip_colors_and_formatting "Bash tips: Colors and formatting (ANSI/VT100 Control sequences)")

## which 命令

`which` 命令 用于查找并显示给定命令的绝对路径，环境变量 `PATH` 中保存了查找命令时需要遍历的目录。`which` 指令会在环境变量 `$PATH` 设置的目录里查找符合条件的文件。也就是说，使用 `which` 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。

```bash
# 选项
which -n<文件名长度> # 制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；
which -p<文件名长度> # 与-n参数相同，但此处的<文件名长度>包含了文件的路径；
which -w # 指定输出时栏位的宽度；
which -V # 显示版本信息。
```

## whereis 命令

`whereis` 命令只能用于程序名的搜索，而且只搜索二进制文件(参数 `-b`)、`man` 说明文件(参数`-m`)和源代码文件(参数`-s`)。如果省略参数，则返回所有信息。

和 `find` 相比，`whereis` 查找的速度非常快，这是因为 `linux` 系统会将 系统内的所有文件都记录在一个数据库文件中，当使用 `whereis` 和下面即将介绍的 `locate` 时，会从数据库中查找数据，而不是像 `find` 命令那样，通过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用 `whereis` 和 `locate` 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。

语法 `whereis [选项] [参数]`

```bash
# 选项
whereis -b # 只查找二进制文件(可执行文件)；
whereis -B<目录> # 只在设置的目录下查找二进制文件；
whereis -f # 不显示文件名前的路径名称；
whereis -m # 只查找说明文件；
whereis -M<目录> # 只在设置的目录下查找说明文件；
whereis -s # 只查找原始代码文件；
whereis -S<目录> # 只在设置的目录下查找原始代码文件；
whereis -u # 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。
```

参数：指令名：要查找的二进制程序、源文件和 `man` 手册页的指令名。

## locate 命令

`locate` 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 `updatedb` 程序来更新，`updatedb` 是由 `cron daemon` 周期性调用的。默认情况下 `locate` 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 `locate` 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，`updatedb` 每天会跑一次，可以由修改 `crontab` 来更新设定值 (`etc/crontab`)。`locate` 与 `find` 命令相似，可以使用如 `*、?`等进行正则匹配查找。

语法 `locate [选项] [模式]`

```bash
# 选项
-b, --basename  # 仅匹配路径名的基本名称
-c, --count     # 只输出找到的数量
-d, --database DBPATH # 使用DBPATH指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db
-e, --existing  # 仅打印当前现有文件的条目
-1 # 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的  权限资料。
-0, --null            # 在输出上带有NUL的单独条目
-S, --statistics      # 不搜索条目，打印有关每个数据库的统计信息
-q                    # 安静模式，不会显示任何错误讯息。
-P, --nofollow, -H    # 检查文件存在时不要遵循尾随的符号链接
-l, --limit, -n LIMIT # 将输出(或计数)限制为LIMIT个条目
-n                    # 至多显示 n个输出。
-m, --mmap            # 被忽略，为了向后兼容
-r, --regexp REGEXP   # 使用基本正则表达式
    --regex           # 使用扩展正则表达式
-q, --quiet           # 安静模式，不会显示任何错误讯息
-s, --stdio           # 被忽略，为了向后兼容
-o                    # 指定资料库存的名称。
-h, --help            # 显示帮助
-i, --ignore-case     # 忽略大小写
-V, --version         # 显示版本信息

# 实例
locate -r '^/var.*reason$' # 查找 /var 目录下，以 reason 结尾的文件
locate pwd # 查找和 pwd 有关的文件
locate /etc/sh # 搜索 etc 目录下所有以 sh 开头的文件
```

## find 命令

`find` 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 `find` 命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示。

语法 `find pathname -options [-print -exec -depth -ok ...]`

```bash
# 选项
-name #按照文件名查找文件
-perm #按文件权限查找文件
-user #按文件属主查找文件
-group  #按照文件所属的组来查找文件。
-type  #查找某一类型的文件，诸如：
# b - 块设备文件
# d - 目录
# c - 字符设备文件
# l - 符号链接文件
# p - 管道文件
# f - 普通文
-size n :[c] # 查找文件长度为n块文件，带有c时表文件字节大小
-amin n   # 查找系统中最后N分钟访问的文件
-atime n  # 查找系统中最后n*24小时访问的文件
-cmin n   # 查找系统中最后N分钟被改变文件状态的文件
-ctime n  # 查找系统中最后n*24小时被改变文件状态的文件
-mmin n   # 查找系统中最后N分钟被改变文件数据的文件
-mtime n  # 查找系统中最后n*24小时被改变文件数据的文件(用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 )
-maxdepth n # 最大查找目录深度
-prune # 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略
-newer # 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项
-print # find命令将匹配的文件输出到标准输出。
-exec # find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
-ok # 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
-depth # 从指定目录下最深层的子目录开始查找；

# 实例
find -atime -2 # 查找48小时内修改过的文件
find ./ -name '*.log' # 在当前目录查找 以 .log 结尾的文件。 . 代表当前目录
find /opt -perm 777 #查找 /opt 目录下 权限为 777 的文件
find -size +1000c #查找大于 1K 的文件
find -size 1000c #查找等于 1000 字符的文件

find . -type f -mtime +10 -exec rm -f {} \; # 在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒）
find . -name '*.log' mtime +5 -ok -exec rm {} \; # 当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除
find . -f -name 'passwd*' -exec grep "pkg" {} \; # 当前目录下查找文件名以 passwd 开头，内容包含 "pkg" 字符的文件
find . -name '*.log' -exec cp {} test3 \; # 用 exec 选项执行 cp 命令
find . -type f -print | xargs file # 查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型
find . -type f -name "*.js" -exec grep -lF 'editor' {} \; # 查找当前目录下所有以 js 结尾的并且其中包含 'editor' 字符的普通文件
find -type f -name '*.js' | xargs grep -lF 'editor' # 查找当前目录下所有以 js 结尾的并且其中包含 'editor' 字符的普通文件
find . -name "*.log" | xargs -i mv {} test4 # 利用 xargs 执行 mv 命令
find . -name \*(转义） -type f -print | xargs grep -n 'hostnames' # 用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行
find . -name '[a-z]*[4-9].log' -print # 查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件
find test -path 'test/test4' -prune -o -print # 
```

> `find` 命令的参数非常多， 用法爷非常多，这里只是列出了很小一部分，如果想详细了解可以用 `man` 命令查看。

## chmod 命令

用于改变 `linux` 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。

每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 `ls -l` 查找。关于 `ls -l` 的各个字段表示什么意思可以看我的另一篇文章[WordPress文件权限问题](https://www.clloz.com/programming/assorted/wordpress/2020/07/28/wordpress-permissions/ "WordPress文件权限问题")

```bash
# 选项
-c 当发生改变时，报告处理信息
-R 处理指定目录以及其子目录下所有文件
```

* * *

权限范围

- `u` ：`user` 目录或者文件的当前的用户
- `g` ：`group` 目录或者文件的当前的群组
- `o` ：`other` 除了目录或者文件的当前用户或群组之外的用户或者群组
- `a` ：`all` 所有的用户及群组

权限代号：

- `r` ：读权限，用数字 `4` 表示
- `w` ：写权限，用数字 `2` 表示
- `x` ：执行权限，用数字 `1` 表示
- `-` ：删除权限，用数字 `0` 表示
- `s` ：特殊权限

```bash
# 实例
chmod a+x t.log # 增加文件 t.log 所有用户可执行权限
chmod u=r t.log -c # 撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息
chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c) # 给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限
chmod u+r,g+r,o+r -R text/ -c # 将 test 目录及其子目录所有文件添加可读权限
```

## tar 命令

用来压缩和解压文件。`tar` 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成（比如 `gzip` 和 `bz2`）。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。`Linux` 中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（`tar` 命令），然后再用压缩程序进行压缩（`gzip` `bzip2`）。

语法

```bash
# 选项
-c #建立新的压缩文件
-f #指定压缩文件
-r #添加文件到已经压缩文件包中
-u #添加改了和现有的文件到压缩包中
-x #从压缩包中抽取文件
-t #显示压缩文件中的内容
-z #支持gzip压缩
-j #支持bzip2压缩
-Z #支持compress解压文件
-v #显示操作过程

#实例
tar -cvf log.tar 1.log,2.log 或tar -cvf log.* # 将文件全部打包成 tar 包
tar -zcvf /tmp/etc.tar.gz /etc # 将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩
tar -ztvf /tmp/etc.tar.gz # 查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）
tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc # 要压缩打包 /home, /etc ，但不要 /home/dmtsai
```

## chown 命令

`chown` 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 `ID`；组可以是组名或者组 `ID`；文件是以空格分开的要改变权限的文件列表，支持通配符。

```bash
# 选项
-c #显示更改的部分的信息
-R #处理指定目录及子目录

# 实例
chown -c mail:mail log2012.log # 改变拥有者和群组 并显示改变信息
chown -c :mail t.log # 改变文件群组
chown -cR mail: test/ # 改变文件夹及子文件目录属主及属组为 mail
```

## df 命令

`df` 命令显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 `1KB` 为单位进行显示，除非环境变量 `POSIXLY_CORRECT` 被指定，那样将以 `512` 字节为单位进行显示。

```bash
# 选项
-a #全部文件系统列表
-h #以方便阅读的方式显示信息
-i #显示inode信息
-k #区块为1024字节
-l #只显示本地磁盘
-T #列出文件系统类型

# 实例
df -l # 显示磁盘使用情况
df -haT # 以易读方式列出所有文件系统及其类型
```

## du 命令

`du` 命令也是查看使用空间的，但是与 `df` 命令不同的是 `du` 命令是对文件和目录磁盘使用的空间的查看。

```bash
# 选项
-a #显示目录中所有文件大小
-k #以KB为单位显示文件大小
-m #以MB为单位显示文件大小
-g #以GB为单位显示文件大小
-h #以易读方式显示文件大小
-s #仅显示总计
-c #或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和

# 实例
du -h scf/ # 以易读方式显示文件夹内及子文件夹大小
du -ah scf/ # 以易读方式显示文件夹内所有文件大小
du -hc test/ scf/ # 显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和
du -hc --max-depth=1 scf/ # 输出当前目录下各个子目录所使用的空间
```

## ln 命令

`ln` 命令的功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 `ln` 创建的链接（`link`）减少磁盘占用量。链接分为硬链接和软链接，关于两者的区别请看我的另一篇文章[WordPress文件权限问题](https://www.clloz.com/programming/assorted/wordpress/2020/07/28/wordpress-permissions/ "WordPress文件权限问题")

```bash
# 选项
-b# 删除，覆盖以前建立的链接
-s #软链接（符号链接）
-v #显示详细处理过程

# 实例
ln -sv source.log link.log # 给文件创建软链接，并显示操作信息
ln -v source.log link1.log # 给文件创建硬链接，并显示操作信息
ln -sv /opt/soft/test/test3 /opt/soft/test/test5 # 给目录创建软链接
```

## date 命令

`Date` 命令显示或设定系统的日期与时间。

```bash
# 选项
-d<字符串> 　#显示字符串所指的日期与时间。字符串前后必须加上双引号。
-s<字符串> 　#根据字符串来设置日期与时间。字符串前后必须加上双引号。
-u 　#显示GMT。
%H #小时(00-23)
%I #小时(00-12)
%M #分钟(以00-59来表示)
%s #总秒数。起算时间为1970-01-01 00:00:00 UTC。
%S #秒(以本地的惯用法来表示)
%a #星期的缩写。
%A #星期的完整名称。
%d #日期(以01-31来表示)。
%D #日期(含年月日)。
%m #月份(以01-12来表示)。
%y #年份(以00-99来表示)。
%Y #年份(以四位数来表示)。

# 实例
date +%Y%m%d --date="+1 day"  #显示下一天的日期
date -d "nov 22"  #今年的 11 月 22 日是星期三
date -d '2 weeks' #2周后的日期
date -d 'next monday' #下周一的日期
date -d next-day +%Y%m%d #明天的日期 或者：date -d tomorrow +%Y%m%d
date -d last-day +%Y%m%d #昨天的日期 或者：date -d yesterday +%Y%m%d
date -d last-month +%Y%m #上个月是几月
date -d next-month +%Y%m #下个月是几月
```

## cal 命令

`cal` 命令可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份。

```bash
#选项
-3 #显示前一月，当前月，后一月三个月的日历
-m #显示星期一为第一列
-j #显示在当前年第几天
-y #[year]显示当前年[year]份的日历

#实例
cal 9 2012 #显示指定年月日期
cal -y 2013 #显示2013年每个月日历
cal -3m #将星期一做为第一列,显示前中后三月
```

## grep 命令

强大的文本搜索命令，`grep(Global Regular Expression Print)` 全局正则表达式搜索。

`grep` 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

关于正则表达式的应用参考我的另一篇文章[正则表达式入门以及JavaScript中的应用](https://www.clloz.com/programming/front-end/js/2020/08/05/regex-javascript-apply/ "正则表达式入门以及JavaScript中的应用")，需要注意一点的是在 `grep` 中分组 `()` 圆括号需要转义。

```bash
#选项
-a --text  # 不要忽略二进制数据。
-A <显示行数>   --after-context=<显示行数>   # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
-b --byte-offset                           # 在显示符合范本样式的那一行之外，并显示该行之前的内容。
-B<显示行数>   --before-context=<显示行数>   # 除了显示符合样式的那一行之外，并显示该行之前的内容。
-c --count    # 计算符合范本样式的列数。
-C<显示行数> --context=<显示行数>或-<显示行数> # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
-d<进行动作> --directories=<动作>  # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。
-e<范本样式> --regexp=<范本样式>   # 指定字符串作为查找文件内容的范本样式。
-E --extended-regexp             # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。
-f<范本文件> --file=<规则文件>     # 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。
-F --fixed-regexp   # 将范本样式视为固定字符串的列表。
-G --basic-regexp   # 将范本样式视为普通的表示法来使用。
-h --no-filename    # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
-H --with-filename  # 在显示符合范本样式的那一列之前，标示该列的文件名称。
-i --ignore-case    # 忽略字符大小写的差别。
-l --file-with-matches   # 列出文件内容符合指定的范本样式的文件名称。
-L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。
-n --line-number         # 在显示符合范本样式的那一列之前，标示出该列的编号。
-P --perl-regexp         # PATTERN 是一个 Perl 正则表达式
-q --quiet或--silent     # 不显示任何信息。
-R/-r  --recursive       # 此参数的效果和指定“-d recurse”参数相同。
-s --no-messages  # 不显示错误信息。
-v --revert-match # 反转查找。
-V --version      # 显示版本信息。
-w --word-regexp  # 只显示全字符合的列。
-x --line-regexp  # 只显示全列符合的列。
-y # 此参数效果跟“-i”相同。
-o # 只输出文件中匹配到的部分。
-m <num> --max-count=<num> # 找到num行结果后停止查找，用来限制匹配行数

#实例
ps -ef | grep svn #查找指定进程
ps -ef | grep svn -c #查找指定进程个数
cat test1.txt | grep -f key.log #从文件中读取关键词
grep -lR '^grep' /tmp #从文件夹中递归查找以grep开头的行，并只列出文件
grep '^[^x]' test.txt #查找非x开头的行内容
grep -E 'ed|at' test.txt #显示包含 ed 或者 at 字符的内容行
```

## wc 命令

`wc(word count)` 命令功能为统计指定的文件中字节数、字数、行数，并将统计结果输出。

```bash
#选项
-c #统计字节数
-l #统计行数
-m #统计字符数
-w #统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串

#实例
wc text.txt #查找文件的 行数 单词数 字节数 文件名，结果：7 8 70 test.txt
cat test.txt | wc -l #统计输出结果的行数

```

## ps 命令

ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top

linux上进程有 `5` 种状态:

1. 运行(正在运行或在运行队列中等待)
2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用 `wait4()` 系统调用后释放)
5. 停止(进程收到 `SIGSTOP, SIGSTP, SIGTIN, SIGTOU` 信号后停止运行运行)

`ps` 工具标识进程的 `5` 种状态码:

1. `D` 不可中断 `uninterruptible sleep (usually IO)`
2. `R` 运行 `runnable (on run queue)`
3. `S` 中断 `sleeping`
4. `T` 停止 `traced or stopped`
5. `Z` 僵死 `a defunct (”zombie”) process`

```bash
# 选项
-A #显示所有进程
a #显示所有进程
-a #显示同一终端下所有进程
c #显示进程真实名称
e #显示环境变量
f #显示进程间的关系
r #显示当前终端运行的进程
-aux #显示所有包含其它使用的进程

# 实例
ps -ef #显示当前所有进程环境变量及进程间关系
ps -A #显示当前所有进程
ps -aux | grep apache #与grep联用查找某进程
ps aux | grep '(cron|syslog)' #找出与 cron 与 syslog 这两个服务有关的 PID 号码
```

## top 命令

`top` 命令显示当前系统正在执行的进程的相关信息，包括进程 `ID`、内存占用率、`CPU` 占用率等。

```bash
#选项
-c 显示完整的进程命令
-s 保密模式
-p <进程号> 指定进程显示
-n <次数>循环显示次数
```

结果的前五行是当前系统情况整体的统计信息区。举例如下的信息：

```bash
top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35
Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie
Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st
Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers
Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND

28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java
```

1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：
    
    - `14:06:23` — 当前系统时间
    - `up 70 days, 16:44` — 系统已经运行了 `70` 天 `16` 小时 `44` 分钟
    - `2 users` — 当前有 `2` 个用户登录系统
    - `load average: 1.15, 1.42, 1.44` — `load average` 后面的三个数分别是 `1` 分钟、`5` 分钟、`15` 分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。
2. 第二行，`Tasks` — 任务（进程），具体信息说明举例：系统现在共有 `206` 个进程，其中处于运行中的有`1`个，`205`个在休眠（`sleep`），`stoped` 状态的有 `0` 个，`zombie` 状态（僵尸）的有 `0` 个。
3. 第三行，cpu状态信息，具体属性说明如下：
    
    - `5.9%us` — 用户空间占用 `CPU` 的百分比。
    - `3.4% sy` — 内核空间占用 `CPU` 的百分比。
    - `0.0% ni` — 改变过优先级的进程占用 `CPU` 的百分比
    - `90.4% id`— 空闲 `CPU` 百分比
    - `0.0% wa` — `IO` 等待占用 `CPU` 的百分比
    - `0.0% hi` — 硬中断（`Hardware IRQ`）占用 `CPU` 的百分比
    - `0.2% si` — 软中断（`Software Interrupts`）占用 `CPU` 的百分比
4. 第四行，内存状态，具体信息如下：
    
    - `32949016k total` — 物理内存总量（`32GB`）
    - `14411180k used` — 使用中的内存总量（`14GB`）
    - `18537836k free` — 空闲内存总量（`18GB`）
    - `169884k buffers` — 缓存的内存量 （`169M`）
5. 第五行，`swap`交换分区信息，具体信息说明如下：
    
    - `32764556k total` — 交换区总量（`32GB`）
    - `0k used` — 使用的交换区总量（`0K`）
    - `32764556k free` — 空闲交换区总量（`32GB`）
    - `3612636k cached` — 缓冲的交换区总量（`3.6GB`）
6. 第六行空行。
7. 第七行以下：各进程（任务）的状态监控，项目列信息说明如下：
    
    - `PID` — 进程 `id`
    - `USER` — 进程所有者
    - `PR` — 进程优先级
    - `NI` — `nice` 值。负值表示高优先级，正值表示低优先级
    - `VIRT` — 进程使用的虚拟内存总量，单位 `kb`。`VIRT=SWAP+RES`
    - `RES` — 进程使用的、未被换出的物理内存大小，单位 `kb`。`RES=CODE+DATA`
    - `SHR` — 共享内存大小，单位 `kb`
    - `S` — 进程状态。
    - `%CPU` — 上次更新到现在的CPU时间占用百分比
    - `%MEM` — 进程使用的物理内存百分比
    - `TIME+` — 进程使用的 `CPU` 时间总计，单位 `1/100` 秒
    - `COMMAND` — 进程名称（命令名/命令行）

* * *

`top` 命令的交互指令

- `h`：显示 `top` 交互命令帮助信息
- `c`：切换显示命令名称和完整命令行
- `m`：以内存使用率排序
- `P` 根据 `CPU` 使用百分比大小进行排序
- `T`：根据时间/累计时间进行排序
- `W`：将当前设置写入`~/.toprc` 文件中
- `o`：或者 `O` 改变显示项目的顺序
- `q`：退出

> `Mac` 下排序需要先输入 `o` 然后输入列名，比如 `mem`，`cpu` 等。

## kill 命令

`kill` 命令发送指定的信号到相应进程。不指定型号将发送 `SIGTERM（15）` 终止指定进程。如果仍无法终止该程序可用 `-KILL` 参数，其发送的信号为`SIGKILL(9)` ，将强制结束进程，使用 `ps` 命令或者 `jobs` 命令可以查看进程号。`root` 用户将影响用户的进程，非 `root` 用户只能影响自己的进程。

```bash
# 选项
-l  #信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
-a  #当处理当前进程时，不限制命令名和进程号的对应关系
-p  #指定kill 命令只打印相关进程的进程号，而不发送任何信号
-s  #指定发送信号
-u  #指定用户

#实例
kill -9 $(ps -ef | grep pro1) #先使用ps查找进程pro1，然后用kill杀掉
```

## free 命令

`free` 命令显示系统内存使用情况，包括物理内存、交互区内存(`swap`)和内核缓冲区内存。

```bash
# 选项
-b #以Byte显示内存使用情况
-k #以kb为单位显示内存使用情况
-m #以mb为单位显示内存使用情况
-g #以gb为单位显示内存使用情况
-s<间隔秒数> #持续显示内存
-t #显示内存使用总合

#实例：
free #显示内存使用情况
free -k #显示内存使用情况
free -m #显示内存使用情况
free -t #以总和的形式显示内存的使用信息
free -s 10 #周期性查询内存使用情况
```

## 参考文章

1. [shell中使用echo命令输出信息及带颜色的文本](https://linuxgeeks.github.io/2015/06/28/154139-shell%E4%B8%AD%E4%BD%BF%E7%94%A8echo%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E5%8F%8A%E5%B8%A6%E9%A2%9C%E8%89%B2%E7%9A%84%E6%96%87%E6%9C%AC/ "shell中使用echo命令输出信息及带颜色的文本")
2. [Linux 常用命令学习](https://www.runoob.com/w3cnote/linux-common-command-2.html "Linux 常用命令学习")
3. [Linux命令搜索](https://wangchujiang.com/linux-command/ "Linux命令搜索")